generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  USER
  SELLER
  MANAGER
  ADMIN
  SUPER_ADMIN
}

enum AuthProvider {
  LOCAL
  GOOGLE
  FACEBOOK
}

enum NotificationType {
  INFO
  SUCCESS
  WARNING
  ERROR
}

enum TransactionType {
  CREDIT
  DEBIT
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}

enum WithdrawalStatus {
  PENDING
  PROCESSING
  COMPLETED
  REJECTED
  CANCELLED
}

enum ConfigType {
  CURRENCY
  SYSTEM
  FEATURE
}

enum CfKeyType {
  CPF
  CNPJ
  EMAIL
  PHONE
  RANDOM
}

enum CfPaymentStatus {
  PENDING
  AWAITING_APPROVAL // Waiting for seller approval
  APPROVED // Seller approved, processing payment
  REJECTED // Seller rejected the payment
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  EXPIRED
}

enum InvoiceStatus {
  PENDING // Fatura gerada, aguardando pagamento
  PAID // Fatura paga
  OVERDUE // Fatura vencida
  CANCELLED // Fatura cancelada
}

enum InvoicePaymentStatus {
  PENDING // Cobrança criada, aguardando pagamento
  PAID // Cobrança paga
  CANCELLED // Cobrança cancelada
  EXPIRED // Cobrança expirou
}

enum InvoicePaymentType {
  MANUAL // Pagamento manual escolhido pelo vendedor
  WEEKLY_AUTO // Pagamento automático semanal
}

enum InvoiceBonusStatus {
  PENDING // Bônus criado, aguardando pagamento da fatura
  RELEASED // Bônus liberado para o usuário
  CANCELLED // Bônus cancelado
}

enum ReferralLinkStatus {
  ACTIVE
  INACTIVE
  EXPIRED
}

enum InvoiceBonusType {
  CASHBACK // Cashback para o comprador
  REFERRAL_BUYER // Bônus de indicação do comprador
  REFERRAL_SELLER // Bônus de indicação do vendedor
  MANAGER // Comissão para gerente
  POOL // Bônus para pool de fundos
  SYSTEM // Bônus para sistema
  COMMISSION // Comissão geral
  OTHER // Outros tipos de bônus
}

enum PaymentProvider {
  OPENPIX // OpenPix PIX provider
  ASAAS   // Asaas PIX provider
}

enum SellerApplicationStatus {
  PENDING // Aguardando análise
  APPROVED_PENDING_AGREEMENT // Aprovado pelo admin, aguardando concordância do vendedor
  APPROVED // Aprovado e aceito pelo vendedor - pode ser convertido
  REJECTED // Rejeitado
  CONVERTED // Já foi convertido em vendedor
}

enum PercentageChangeRequestStatus {
  PENDING // Aguardando aprovação do vendedor
  APPROVED // Aprovado pelo vendedor
  REJECTED // Rejeitado pelo vendedor
}

enum PromotionRequestStatus {
  PENDING // Aguardando decisão do usuário
  ACCEPTED // Usuário aceitou a promoção
  REJECTED // Usuário rejeitou a promoção
}

enum EmployeePermission {
  // Acesso total
  FULL_ACCESS

  // Visualização de dados financeiros
  VIEW_BALANCE
  VIEW_TRANSFERS
  VIEW_PAYMENTS

  // Gerenciamento operacional
  MANAGE_SALES
  MANAGE_PRODUCTS
  MANAGE_INVOICES
  MANAGE_SOCIAL_NETWORK
}

enum EmployeeStatus {
  PENDING // Convite enviado, aguardando aceitação do funcionário
  ACTIVE // Funcionário aceitou o convite
  INACTIVE
  SUSPENDED
}


enum PremiumRequestStatus {
  PENDING // Aguardando aprovação do gerente
  APPROVED // Aprovado pelo gerente
  REJECTED // Rejeitado pelo gerente
}

enum WalletType {
  PERSONAL // Carteira pessoal (padrão)
  NOTAX // Carteira sem impostos
  BUSINESS // Carteira empresarial (associada a BusinessProfile)
}

enum PersonType {
  PF // Pessoa Física
  PJ // Pessoa Jurídica
}

enum BusinessProfileStatus {
  UNVERIFIED // Não verificado
  VERIFIED // Verificado
  PENDING_PREMIUM // Aguardando aprovação para premium
  PREMIUM // Premium
  CANCELLED // Cancelado
}

enum WhatsAppQueueStatus {
  PENDING // Aguardando envio
  SCHEDULED // Agendado para envio futuro
  SENT // Enviado com sucesso
  FAILED // Falha no envio
  CANCELLED // Cancelado
}

enum WhatsAppAttemptStatus {
  PENDING // Tentativa sendo processada
  SENT // Mensagem enviada com sucesso
  FAILED // Falha ao enviar
}

model User {
  id           String        @id @default(cuid())
  email        String        @unique
  name         String
  password     String?
  avatar       String?
  phone        String? // Telefone do usuário
  cpf          String?       @unique // CPF do usuário (único)
  birthDate    DateTime? // Data de nascimento
  whatsapp     String? // WhatsApp pessoal
  instagram    String? // Instagram pessoal
  facebook     String? // Facebook pessoal
  role         UserRole      @default(USER)
  provider     AuthProvider? @default(LOCAL)
  providerId   String?
  referralCode String?       @unique
  referredBy   String?
  managerId    String? // ID do gerente responsável por este usuário
  managerCommissionPercentage Decimal? @db.Decimal(5, 2) // % que repassa para seu gerente superior
  status       String        @default("ACTIVE") // ACTIVE, INACTIVE, SUSPENDED
  isVerified   Boolean       @default(false)
  isActive     Boolean       @default(true)
  paymentData  Json? // Dados de pagamento PIX (nome, cpf, email, telefone)
  hasCompletedProfileSelection Boolean @default(false) // Se o usuário já completou a seleção de perfil na primeira vez

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  referrer                 User?                     @relation("UserReferrals", fields: [referredBy], references: [id])
  referrals                User[]                    @relation("UserReferrals")
  manager                  User?                     @relation("UserManager", fields: [managerId], references: [id])
  managedUsers             User[]                    @relation("UserManager")
  businessProfiles         BusinessProfile[]
  sessions                 Session[]
  notifications            Notification[]
  wallets                  Wallet[]
  transactions             Transaction[]
  cfKeys                  CfKey[]
  buyerCfPayments  CfPayment[]     @relation("BuyerCfPayments")
  sellerCfPayments CfPayment[]     @relation("SellerCfPayments")
  taxes             InvoiceTax[]
  invoices          Invoice[]
  invoiceBonuses    InvoiceTaxBonus[]
  sellerApplications       SellerApplication[]
  percentageChangeRequests PercentageChangeRequest[]
  promotionRequests        PromotionRequest[]        @relation("PromotionRequests")
  promotionRequestsSent    PromotionRequest[]        @relation("PromotionRequestsSent")
  premiumRequests          PremiumRequest[]
  premiumRequestsApproved  PremiumRequest[]          @relation("PremiumRequestApprovers")

  // Ofertas (sistema de ofertas)
  offers               Offer[]           @relation("SellerOffers")
  redemptions          OfferRedemption[] @relation("UserRedemptions")
  reviewedRedemptions  OfferRedemption[] @relation("ReviewedRedemptions")
  validatedRedemptions OfferRedemption[] @relation("ValidatedRedemptions")
  favorites            OfferFavorite[]   @relation("UserFavorites")
  offerViews           OfferView[]       @relation("UserViews")

  // Gerenciamento de empresas
  managedBusinessProfiles BusinessProfile[] @relation("BusinessProfileManagers")
  employees           Employee[]

  // Saques
  withdrawals         Withdrawal[] // Saques solicitados pelo usuário
  processedWithdrawals Withdrawal[] @relation("ProcessedWithdrawals") // Saques processados por este admin

  // Reset de senha
  passwordResetCodes  PasswordResetCode[]

  // Autenticação biométrica
  biometricCredentials BiometricCredential[]

  // Área Social
  posts          Post[]            @relation("UserPosts")
  postLikes      PostLike[]        @relation("UserPostLikes")
  postComments   PostComment[]     @relation("UserPostComments")
  commentLikes   PostCommentLike[] @relation("UserCommentLikes")
  followers      UserFollow[]      @relation("UserFollowing") // Pessoas que me seguem
  following      UserFollow[]      @relation("UserFollowers") // Pessoas que eu sigo
  businessProfileFollows BusinessProfileFollow[] @relation("BusinessProfileFollowers") // Empresas que eu sigo
  postShares     PostShare[]       @relation("UserPostShares")
  stories        Story[]           @relation("UserStories")
  storyViews     StoryView[]       @relation("UserStoryViews")

  // Links de indicação
  referralLinks  ReferralLink[]    @relation("ReferralLinksCreated")

  // Fila de WhatsApp
  whatsappQueue  WhatsAppQueue[]   @relation("UserWhatsAppQueue")

  @@map("users")
}

model BusinessProfile {
  id     String @id @default(cuid())
  userId String // Um usuário pode ter múltiplos business profiles
  managerId String? // ID do gerente responsável por esta empresa

  // Business type
  personType PersonType @default(PJ)

  // Status do perfil
  status BusinessProfileStatus @default(UNVERIFIED)

  // PF fields (apenas para pessoa física)
  cpf String? @unique // CPF do negócio (único ou nulo)

  // PJ fields (apenas para empresas)
  companyName String? // Razão social
  cnpj        String? @unique // CNPJ único ou nulo
  tradingName String? // Nome fantasia
  description String? @db.Text
  companyLogo String?
  categories  String? // JSON array de categorias

  // Business Address (endereço comercial)
  cep          String?
  street       String?
  number       String?
  complement   String?
  neighborhood String?
  city         String?
  state        String?
  latitude     Float?
  longitude    Float?

  // Business Social media (redes sociais da empresa)
  instagram String?
  facebook  String?
  whatsapp  String?
  website   String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user              User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  manager           User?           @relation("BusinessProfileManagers", fields: [managerId], references: [id], onDelete: SetNull)
  wallets           Wallet[]        @relation("BusinessWallets")
  cfPayments       CfPayment[]
  invoiceTaxes      InvoiceTax[]
  invoices          Invoice[]
  premiumRequests   PremiumRequest[]
  posts             Post[]          @relation("BusinessProfilePosts")
  followers         BusinessProfileFollow[] @relation("BusinessProfileFollowers")
  employees         Employee[]

  @@index([managerId])
  @@map("business_profiles")
}

model Session {
  id           String   @id @default(cuid())
  userId       String
  accessToken  String   @unique
  refreshToken String   @unique
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  title     String
  message   String
  type      NotificationType @default(INFO)
  data      Json?
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model CronJob {
  id          String    @id @default(cuid())
  name        String    @unique
  description String?
  schedule    String
  isActive    Boolean   @default(true)
  lastRun     DateTime?
  nextRun     DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@map("cron_jobs")
}

model CronJobExecution {
  id        String    @id @default(cuid())
  jobName   String
  status    String
  result    Json?
  error     String?
  duration  Int?
  startedAt DateTime  @default(now())
  endedAt   DateTime?

  @@map("cron_job_executions")
}

model Wallet {
  id                 String     @id @default(cuid())
  userId             String
  businessProfileId  String?
  type               WalletType @default(PERSONAL)
  balance            Decimal    @default(0.00) @db.Decimal(10, 2)
  frozenAmount       Decimal    @default(0.00) @db.Decimal(10, 2)
  createdAt          DateTime   @default(now())
  updatedAt          DateTime   @updatedAt

  // Relations
  user             User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  businessProfile  BusinessProfile?   @relation("BusinessWallets", fields: [businessProfileId], references: [id], onDelete: SetNull)
  transactions     Transaction[]
  withdrawals      Withdrawal[]

  @@unique([userId, type]) // Um usuário pode ter apenas uma carteira por tipo
  @@index([userId])
  @@index([businessProfileId])
  @@map("wallets")
}

model Transaction {
  id            String            @id @default(cuid())
  userId        String
  walletId      String?
  amount        Decimal           @db.Decimal(10, 2)
  type          TransactionType
  status        TransactionStatus @default(PENDING)
  description   String
  category      String?
  reference     String? // Reference to external transaction ID
  cfPaymentId  String? // Reference to CF payment
  metadata      Json? // Additional data like fees, exchange rates, etc.
  balanceBefore Decimal           @db.Decimal(10, 2)
  balanceAfter  Decimal           @db.Decimal(10, 2)
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  // Relations
  user       User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  wallet     Wallet?      @relation(fields: [walletId], references: [id], onDelete: SetNull)
  cfPayment CfPayment?  @relation(fields: [cfPaymentId], references: [id], onDelete: SetNull)
  withdrawal Withdrawal?

  @@index([userId, createdAt])
  @@index([walletId])
  @@index([cfPaymentId])
  @@map("transactions")
}

model SystemConfig {
  id          String     @id @default(cuid())
  key         String     @unique
  value       String
  type        ConfigType @default(SYSTEM)
  description String?
  isActive    Boolean    @default(true)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@map("system_configs")
}

model CfKey {
  id        String     @id @default(cuid())
  userId    String
  keyType   CfKeyType
  keyValue  String     @unique
  isActive  Boolean    @default(true)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @default(now())

  // Relations
  user             User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  receivedPayments CfPayment[]

  @@map("cf_keys")
}

model CfPayment {
  id              String           @id @default(cuid())
  buyerId         String? // Buyer user ID (who pays) - Can be null if link not paid yet
  sellerId        String? // Seller user ID (who receives) - Can be null if external payment
  businessProfileId String? // Business profile associated with this payment (if seller is logged with business)
  cfKeyId        String? // Reference to the CF key used
  amount          Decimal          @db.Decimal(10, 2) // Total amount requested
  cfAmount       Decimal?         @db.Decimal(10, 2) // Amount paid in CF
  remainingAmount Decimal?         @db.Decimal(10, 2) // Remaining amount in R$
  description     String?
  status          CfPaymentStatus @default(PENDING)

  // Payment identification
  endToEndId    String  @unique // E2E ID for CF
  transactionId String? // Our internal transaction ID

  // Link/QR Code data
  paymentCode String?   @unique // Custom code for copy-paste
  qrCodeData  String? // QR code payload
  expiresAt   DateTime? // For temporary payment links

  // Approval flow
  pendingApproval Boolean   @default(false)
  approvedAt      DateTime? // When seller approved
  rejectedAt      DateTime? // When seller rejected
  rejectionReason String? // Why seller rejected
  completedAt     DateTime? // When payment was completed

  // Metadata
  metadata     Json?
  errorMessage String?

    sellerComment String?
    proofUrls     Json?
    orderReference String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  buyer            User?              @relation("BuyerCfPayments", fields: [buyerId], references: [id], onDelete: SetNull)
  seller           User?              @relation("SellerCfPayments", fields: [sellerId], references: [id], onDelete: SetNull)
  businessProfile  BusinessProfile?   @relation(fields: [businessProfileId], references: [id], onDelete: SetNull)
  cfKey           CfKey?            @relation(fields: [cfKeyId], references: [id], onDelete: SetNull)
  taxes            InvoiceTax[]       @relation("PaymentInvoicesTax")
  invoice          Invoice?           @relation("InvoiceCf")
  transactions     Transaction[]      // Transações relacionadas a este pagamento CF

  // Items do payment link (PDV ou payment link)
  items              CfPaymentItem[]

  @@index([endToEndId])
  @@index([paymentCode])
  @@index([buyerId, createdAt])
  @@index([sellerId, createdAt])
  @@index([businessProfileId])
  @@map("cf_payments")
}

model CfPaymentItem {
  id              String   @id @default(cuid())
  cfPaymentId    String?  // Relacionamento com o pagamento CF

  // Dados do item
  offerId         String?  // ID da oferta (se for do PDV)
  name            String   // Nome do produto/serviço
  description     String?  @db.Text // Descrição detalhada
  quantity        Int      @default(1) // Quantidade
  unitPrice       Decimal  @db.Decimal(10, 2) // Preço unitário
  totalPrice      Decimal  @db.Decimal(10, 2) // Quantidade * unitPrice

  // Metadados opcionais
  sku             String?  // Código do produto
  category        String?  // Categoria
  percentage      Decimal? @db.Decimal(5, 2) // Percentual CF do produto

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  cfPayment      CfPayment? @relation(fields: [cfPaymentId], references: [id], onDelete: SetNull)

  @@index([cfPaymentId])
  @@map("cf_payments_items")
}

model InvoiceTax {
  id                String  @id @default(cuid())
  userId            String  // Vendedor que deve pagar a fatura
  businessProfileId String? // Empresa associada (se pagamento foi feito por empresa)
  cfPaymentId      String? // Pagamento CF que gerou esta(s) fatura(s) - múltiplas invoices por payment

  // Dados da fatura
  invoiceNumber  String  @unique // Número da fatura (formato: INV-YYYYMM-XXXXX)
  description    String // Descrição da fatura
  amount         Decimal @db.Decimal(10, 2) // Valor da fatura (10% do pagamento ou taxa do produto)
  originalAmount Decimal @db.Decimal(10, 2) // Valor original do pagamento CF ou do item
  percentage     Decimal @default(10.00) @db.Decimal(5, 2) // Percentual cobrado (taxa por produto ou padrão)

  // Status e datas
  status   InvoiceStatus @default(PENDING)
  issuedAt DateTime      @default(now()) // Data de emissão
  dueDate  DateTime // Data de vencimento (30 dias após emissão)
  paidAt   DateTime? // Data de pagamento

  // Informações de pagamento
  paymentMethod    String? // Método usado para pagar (quando pago)
  paymentReference String? // Referência do pagamento (quando pago)

  // Metadados
  metadata Json? // Dados adicionais
  notes    String? // Observações

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user             User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  businessProfile  BusinessProfile?  @relation(fields: [businessProfileId], references: [id], onDelete: SetNull)
  cfPayment       CfPayment?       @relation("PaymentInvoicesTax", fields: [cfPaymentId], references: [id], onDelete: SetNull)
  items            InvoiceItem[]
  bonuses          InvoiceTaxBonus[]

  @@index([userId, status])
  @@index([dueDate, status])
  @@index([invoiceNumber])
  @@index([businessProfileId])
  @@index([cfPaymentId])
  @@map("invoice_tax")
}

model Invoice {
  id                String  @id @default(cuid())
  userId            String  // Vendedor que está pagando
  businessProfileId String? // Empresa associada (se cobrança foi feita por empresa)

  // Dados da cobrança agrupada
  paymentNumber String  @unique // Número da cobrança (formato: PAY-YYYYMM-XXXXX)
  description   String // Descrição da cobrança
  totalAmount   Decimal @db.Decimal(10, 2) // Valor total da cobrança
  invoiceCount  Int // Quantidade de faturas agrupadas

  // Tipo e configuração
  type      InvoicePaymentType // MANUAL ou WEEKLY_AUTO
  maxAmount Decimal?           @db.Decimal(10, 2) // Valor máximo (para pagamentos manuais)

  // Status e datas
  status    InvoicePaymentStatus @default(PENDING)
  dueDate   DateTime // Data de vencimento
  paidAt    DateTime? // Data de pagamento
  expiresAt DateTime? // Data de expiração (para links de pagamento)

  // Informações de pagamento
  paymentMethod         String? // Método usado para pagar (após concluir)
  selectedPaymentMethod String? // Método selecionado pelo usuário (antes de processar)
  paymentReference      String? // Referência do pagamento
  cfPaymentId          String? @unique // ID do pagamento CF (se pago via CF)
  paymentProvider      PaymentProvider? // Provider de PIX selecionado (OPENPIX ou ASAAS)

  // Dados PIX (OpenPix)
  pixChargeId    String?   @unique // ID da cobrança no OpenPix
  pixBrCode      String?   @db.Text // Código PIX (BR Code)
  pixQrCodeImage String?   @db.Text // URL da imagem do QR Code
  pixExpiresAt   DateTime? // Data de expiração do PIX
  openpixChargeId String? @unique // ID da cobrança no OpenPix (alternativo)

  // Dados PIX (Asaas)
  asaasChargeId   String? @unique // ID da cobrança no Asaas
  asaasCustomerId String? // ID do cliente no Asaas

  // Metadados
  metadata Json? // Dados adicionais
  notes    String? // Observações

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user             User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  businessProfile  BusinessProfile?  @relation(fields: [businessProfileId], references: [id], onDelete: SetNull)
  items            InvoiceItem[]
  cfPayment       CfPayment?       @relation("InvoiceCf", fields: [cfPaymentId], references: [id], onDelete: SetNull)

  @@index([userId, status])
  @@index([paymentNumber])
  @@index([dueDate, status])
  @@index([businessProfileId])
  @@map("invoice")
}

model InvoiceItem {
  id        String @id @default(cuid())
  invoiceId String // ID da cobrança agrupada
  taxId     String // ID da fatura individual (invoice_tax)

  // Dados do item
  amount      Decimal @db.Decimal(10, 2) // Valor da fatura
  description String // Descrição da fatura

  createdAt DateTime @default(now())

  // Relations
  invoice Invoice    @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  tax     InvoiceTax @relation(fields: [taxId], references: [id], onDelete: Cascade)

  @@unique([invoiceId, taxId])
  @@map("invoice_items")
}

model InvoiceTaxBonus {
  id          String  @id @default(cuid())
  invoiceId   String // Fatura que gerou este bônus
  userId      String // Usuário que receberá o bônus
  buyerUserId String? // ID do comprador (para rastrear de onde veio)

  // Dados do bônus
  bonusType      InvoiceBonusType // Tipo de bônus (CASHBACK, REFERRAL, etc.)
  amount         Decimal          @db.Decimal(10, 2) // Valor do bônus
  percentage     Decimal          @db.Decimal(5, 2) // Percentual usado para calcular
  originalAmount Decimal          @db.Decimal(10, 2) // Valor original da transação CF
  description    String // Descrição do bônus

  // Status e datas
  status      InvoiceBonusStatus @default(PENDING)
  createdAt   DateTime           @default(now()) // Quando o bônus foi criado
  releasedAt  DateTime? // Quando o bônus foi liberado
  cancelledAt DateTime? // Quando o bônus foi cancelado

  // Informações de liberação
  transactionId String? // ID da transação quando liberado
  walletType    String? // Tipo de carteira creditada (main/withdrawable)

  // Metadados
  metadata Json? // Dados adicionais
  notes    String? // Observações

  updatedAt DateTime @updatedAt

  // Relations
  invoice InvoiceTax @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  user    User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([invoiceId])
  @@index([userId, status])
  @@index([bonusType, status])
  @@map("invoice_tax_bonuses")
}

model SellerApplication {
  id     String @id @default(cuid())
  userId String // Usuário que quer ser vendedor

  // Dados do formulário
  businessName String // Nome do negócio/empresa
  phone        String // Telefone de contato
  message      String @db.Text // Mensagem explicando por que quer ser vendedor

  // Status e controle
  status   SellerApplicationStatus @default(PENDING)
  priority Int                     @default(0) // Para priorização no funil

  // Datas importantes
  submittedAt DateTime  @default(now()) // Quando foi submetido
  reviewedAt  DateTime? // Quando foi analisado
  convertedAt DateTime? // Quando foi convertido em vendedor

  // Dados do revisor
  reviewedBy      String? // ID do admin que analisou
  reviewNotes     String? // Notas do revisor
  rejectionReason String? // Motivo da rejeição (se aplicável)
  agreePercentage Int? // Percentual acordado entre loja e Vortex (1-99%)

  // Concordância do vendedor
  sellerAgreedAt DateTime? // Quando o vendedor concordou com o percentual
  sellerNotes    String? // Comentários do vendedor sobre o acordo

  // Metadados
  metadata Json? // Dados adicionais
  tags     String? // Tags para organização (separadas por vírgula)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user                     User                      @relation(fields: [userId], references: [id], onDelete: Cascade)
  percentageChangeRequests PercentageChangeRequest[]

  @@index([userId])
  @@index([status, priority])
  @@index([submittedAt])
  @@map("seller_applications")
}

model PercentageChangeRequest {
  id                  String @id @default(cuid())
  userId              String // Usuário (comprador) que solicita
  sellerApplicationId String // Aplicação do vendedor relacionada

  currentPercentage   Int // Percentual atual
  requestedPercentage Int // Percentual solicitado
  reason              String? @db.Text // Motivo da solicitação

  status PercentageChangeRequestStatus @default(PENDING)

  // Resposta do vendedor
  reviewedAt  DateTime? // Quando foi analisado
  reviewedBy  String? // ID do vendedor que analisou
  reviewNotes String?   @db.Text // Notas do vendedor

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  sellerApplication SellerApplication @relation(fields: [sellerApplicationId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([sellerApplicationId])
  @@index([status])
  @@map("percentage_change_requests")
}

model PromotionRequest {
  id        String   @id @default(cuid())
  userId    String   // Usuário que será promovido
  managerId String   // Gerente que está convidando

  status PromotionRequestStatus @default(PENDING)

  // Porcentagem que será atribuída ao novo gerente
  managerCommissionPercentage Decimal? @db.Decimal(5, 2)

  // Resposta do usuário
  respondedAt DateTime? // Quando o usuário respondeu
  message     String?   @db.Text // Mensagem opcional do gerente

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user    User @relation("PromotionRequests", fields: [userId], references: [id], onDelete: Cascade)
  manager User @relation("PromotionRequestsSent", fields: [managerId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([managerId])
  @@index([status])
  @@map("promotion_requests")
}

model PremiumRequest {
  id                String   @id @default(cuid())
  businessProfileId String   // ID da empresa que solicita
  userId            String   // ID do proprietário da empresa

  // Dados da solicitação
  observation String? @db.Text // Observação/motivo da solicitação
  phone       String  // Telefone de contato

  // Status e aprovação
  status             PremiumRequestStatus @default(PENDING)
  percentage         Decimal?             @db.Decimal(5, 2) // Percentual atribuído ao aprovar (preenchido pelo gerente)
  approvedBy         String?              // ID do gerente que aprovou
  approvalNotes      String?              @db.Text // Notas do gerente ao aprovar

  // Datas
  approvedAt DateTime? // Quando foi aprovado
  rejectedAt DateTime? // Quando foi rejeitado
  rejectionReason String? // Motivo da rejeição

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  businessProfile BusinessProfile @relation(fields: [businessProfileId], references: [id], onDelete: Cascade)
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  approver        User?           @relation("PremiumRequestApprovers", fields: [approvedBy], references: [id])

  @@index([businessProfileId])
  @@index([userId])
  @@index([status])
  @@map("premium_requests")
}

// === SISTEMA DE OFERTAS ===

enum OfferStatus {
  ACTIVE
  INACTIVE
  EXPIRED
  SOLD_OUT
}

enum RedemptionStatus {
  REQUESTED // Cliente solicitou, aguardando aprovação do vendedor
  APPROVED // Vendedor aprovou, QR gerado
  REJECTED // Vendedor rejeitou a solicitação
  VALIDATED // QR foi usado no estabelecimento
  EXPIRED // QR expirou sem ser usado
  CANCELLED // Cancelado pelo cliente ou sistema
}

model Offer {
  id       String @id @default(cuid())
  sellerId String // Vendedor que criou a oferta

  // Informações do produto/serviço
  title         String // Nome do produto/serviço
  description   String?  @db.Text // Descrição detalhada
  price         Decimal  @db.Decimal(10, 2) // Preço do produto
  originalPrice Decimal? @db.Decimal(10, 2) // Preço original (para mostrar desconto)

  // Configurações da oferta
  percentage     Int // Percentual que a Vortex receberá (deve ser >= percentual acordado)
  quantity       Int // Quantidade total disponível
  quantityUsed   Int @default(0) // Quantos já foram utilizados
  limitPerPerson Int @default(1) // Limite por pessoa (padrão: 1)

  // Vigência
  expiresAt DateTime // Data limite da oferta

  // Mídia e categorização
  images   String  @db.Text // JSON array das URLs das imagens
  category String? // Categoria do produto
  tags     String? // Tags separadas por vírgula

  // Regras e condições
  rules           String  @db.Text // Regras da oferta (campo de texto livre)
  termsConditions String? @db.Text // Termos e condições específicos

  // Localização (herdada do seller)
  requiresPhysicalPresence Boolean @default(true) // Se precisa ir ao estabelecimento

  // Status e metadados
  status        OfferStatus @default(ACTIVE)
  isPromoted    Boolean     @default(false) // Se é uma oferta promovida
  promotedUntil DateTime? // Até quando fica promovida

  // Analytics
  viewCount    Int @default(0) // Contador de visualizações
  requestCount Int @default(0) // Contador de solicitações

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  seller      User              @relation("SellerOffers", fields: [sellerId], references: [id], onDelete: Cascade)
  redemptions OfferRedemption[]
  favorites   OfferFavorite[]
  views       OfferView[]

  @@index([sellerId])
  @@index([status, expiresAt])
  @@index([category])
  @@index([createdAt])
  @@index([isPromoted, promotedUntil])
  @@map("offers")
}

model OfferRedemption {
  id      String           @id @default(cuid())
  offerId String // ID da oferta
  userId  String // ID do cliente
  status  RedemptionStatus @default(REQUESTED)

  // Dados da solicitação
  requestedAt    DateTime @default(now())
  requestMessage String? // Mensagem opcional do cliente
  customerPhone  String? // Telefone para contato

  // Dados da aprovação/rejeição
  reviewedAt      DateTime? // Quando foi analisada
  reviewedBy      String? // ID do vendedor que analisou
  rejectionReason String? // Motivo da rejeição

  // Dados do QR Code (gerado apenas após aprovação)
  code          String?   @unique // Código único: CF-ABC123
  qrCodeData    String? // Dados do QR Code
  qrGeneratedAt DateTime? // Quando o QR foi gerado
  expiresAt     DateTime? // Quando o QR expira (definido pelo vendedor)

  // Dados da utilização
  validatedAt DateTime? // Quando foi validado no estabelecimento
  validatedBy String? // ID de quem validou (normalmente o próprio vendedor)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  offer     Offer @relation(fields: [offerId], references: [id], onDelete: Cascade)
  user      User  @relation("UserRedemptions", fields: [userId], references: [id], onDelete: Cascade)
  reviewer  User? @relation("ReviewedRedemptions", fields: [reviewedBy], references: [id])
  validator User? @relation("ValidatedRedemptions", fields: [validatedBy], references: [id])

  @@index([offerId])
  @@index([userId])
  @@index([status])
  @@index([requestedAt])
  @@index([code])
  @@map("offer_redemptions")
}

model OfferFavorite {
  id        String   @id @default(cuid())
  userId    String // Usuário que favoritou
  offerId   String // Oferta favoritada
  createdAt DateTime @default(now())

  // Relations
  user  User  @relation("UserFavorites", fields: [userId], references: [id], onDelete: Cascade)
  offer Offer @relation(fields: [offerId], references: [id], onDelete: Cascade)

  @@unique([userId, offerId])
  @@index([userId])
  @@index([offerId])
  @@map("offer_favorites")
}

model OfferView {
  id        String   @id @default(cuid())
  offerId   String // Oferta visualizada
  userId    String? // Usuário (null para anônimos)
  ipAddress String? // IP para controle de visualizações anônimas
  userAgent String? // User agent para analytics
  viewedAt  DateTime @default(now())

  // Relations
  offer Offer @relation(fields: [offerId], references: [id], onDelete: Cascade)
  user  User? @relation("UserViews", fields: [userId], references: [id], onDelete: Cascade)

  @@index([offerId])
  @@index([userId])
  @@index([viewedAt])
  @@map("offer_views")
}

model Withdrawal {
  id              String           @id @default(cuid())
  userId          String
  walletId        String?          // ID da carteira de origem do saque
  amount          Decimal          @db.Decimal(10, 2) // Valor solicitado pelo usuário
  fee             Decimal          @default(3.00) @db.Decimal(10, 2) // Taxa de saque (R$ 3,00)
  netAmount       Decimal          @db.Decimal(10, 2) // Valor líquido a receber (amount - fee)
  status          WithdrawalStatus @default(PENDING)
  transactionId   String?          @unique // Transação de débito da carteira sacável
  bankDetails     Json?            // Dados bancários para transferência
  adminNotes      String?          @db.Text // Notas do administrador
  rejectionReason String?          @db.Text // Motivo da rejeição
  processedBy     String?          // ID do admin que processou
  processedAt     DateTime?        // Data de processamento
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  // Relations
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  wallet      Wallet?      @relation(fields: [walletId], references: [id], onDelete: SetNull)
  transaction Transaction? @relation(fields: [transactionId], references: [id])
  processor   User?        @relation("ProcessedWithdrawals", fields: [processedBy], references: [id])

  @@index([userId])
  @@index([walletId])
  @@index([status])
  @@index([createdAt])
  @@map("withdrawals")
}

model BiometricCredential {
  id            String   @id @default(cuid())
  userId        String
  credentialId  String   @unique // ID da credencial WebAuthn (base64url)
  publicKey     Bytes    // Chave pública em formato binário
  counter       Int      @default(0) // Contador de autenticações (segurança anti-clonagem)
  deviceName    String?  // Nome amigável do dispositivo (ex: "iPhone de Victor")
  deviceType    String?  // Tipo: "mobile", "desktop", "tablet"
  transports    Json?    // Array de transportes suportados: ["internal", "usb", "nfc", "ble"]

  createdAt     DateTime @default(now())
  lastUsedAt    DateTime?

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([credentialId])
  @@map("biometric_credentials")
}

// === ÁREA SOCIAL (Instagram-like) ===

enum PostVisibility {
  PUBLIC // Todos podem ver
  FOLLOWERS // Apenas seguidores
  PRIVATE // Apenas o autor
}

enum StoryMediaType {
  IMAGE
  VIDEO
}

model Post {
  id       String         @id @default(cuid())
  userId   String? // Autor do post (opcional quando tem businessProfileId)
  businessProfileId String? // Empresa associada ao post
  content  String?        @db.Text // Texto do post
  images   String?        @db.Text // JSON array de URLs de imagens
  video    String? // URL do vídeo
  location String? // Localização (cidade, estado)

  // Integração com CF
  cfPaymentId String? // Link com pagamento CF (se for oferta)
  offerId      String? // Link com oferta do marketplace

  // Visibilidade e promoção
  visibility    PostVisibility @default(PUBLIC)
  isPromoted    Boolean        @default(false) // Post patrocinado
  promotedUntil DateTime? // Até quando fica promovido

  // Analytics
  viewCount    Int @default(0)
  likeCount    Int @default(0)
  commentCount Int @default(0)
  shareCount   Int @default(0)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  author           User?            @relation("UserPosts", fields: [userId], references: [id], onDelete: Cascade)
  businessProfile  BusinessProfile? @relation("BusinessProfilePosts", fields: [businessProfileId], references: [id], onDelete: Cascade)
  likes            PostLike[]
  comments         PostComment[]
  shares           PostShare[]

  @@index([userId, createdAt])
  @@index([businessProfileId, createdAt])
  @@index([visibility, createdAt])
  @@index([isPromoted, promotedUntil])
  @@map("posts")
}

model PostLike {
  id        String   @id @default(cuid())
  postId    String
  userId    String
  createdAt DateTime @default(now())

  // Relations
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation("UserPostLikes", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([postId])
  @@index([userId])
  @@map("post_likes")
}

model PostComment {
  id        String  @id @default(cuid())
  postId    String
  userId    String
  parentId  String? // Para respostas (replies)
  content   String  @db.Text
  likeCount Int     @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  post    Post              @relation(fields: [postId], references: [id], onDelete: Cascade)
  author  User              @relation("UserPostComments", fields: [userId], references: [id], onDelete: Cascade)
  parent  PostComment?      @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies PostComment[]     @relation("CommentReplies")
  likes   PostCommentLike[]

  @@index([postId, createdAt])
  @@index([userId])
  @@index([parentId])
  @@map("post_comments")
}

model PostCommentLike {
  id        String   @id @default(cuid())
  commentId String
  userId    String
  createdAt DateTime @default(now())

  // Relations
  comment PostComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user    User        @relation("UserCommentLikes", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([commentId, userId])
  @@index([commentId])
  @@index([userId])
  @@map("post_comment_likes")
}

model UserFollow {
  id          String   @id @default(cuid())
  followerId  String // Quem está seguindo
  followingId String // Quem está sendo seguido
  createdAt   DateTime @default(now())

  // Relations
  follower  User @relation("UserFollowers", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("UserFollowing", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("user_follows")
}

model BusinessProfileFollow {
  id                  String   @id @default(cuid())
  followerId          String // ID do usuário que está seguindo
  businessProfileId   String // ID do businessProfile sendo seguido
  createdAt           DateTime @default(now())

  // Relations
  follower        User             @relation("BusinessProfileFollowers", fields: [followerId], references: [id], onDelete: Cascade)
  businessProfile BusinessProfile  @relation("BusinessProfileFollowers", fields: [businessProfileId], references: [id], onDelete: Cascade)

  @@unique([followerId, businessProfileId])
  @@index([followerId])
  @@index([businessProfileId])
  @@map("business_profile_follows")
}

model PostShare {
  id         String   @id @default(cuid())
  postId     String
  userId     String // Quem compartilhou
  sharedWith String? // Com quem compartilhou (userId ou "PUBLIC")
  createdAt  DateTime @default(now())

  // Relations
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation("UserPostShares", fields: [userId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([userId])
  @@map("post_shares")
}

model Story {
  id        String         @id @default(cuid())
  userId    String
  mediaUrl  String // URL da imagem ou vídeo
  mediaType StoryMediaType
  viewCount Int            @default(0)
  expiresAt DateTime // 24h após criação
  createdAt DateTime       @default(now())

  // Relations
  author User        @relation("UserStories", fields: [userId], references: [id], onDelete: Cascade)
  views  StoryView[]

  @@index([userId, createdAt])
  @@index([expiresAt])
  @@map("stories")
}

model StoryView {
  id       String   @id @default(cuid())
  storyId  String
  userId   String
  viewedAt DateTime @default(now())

  // Relations
  story Story @relation(fields: [storyId], references: [id], onDelete: Cascade)
  user  User  @relation("UserStoryViews", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([storyId, userId])
  @@index([storyId])
  @@index([userId])
  @@map("story_views")
}

model ReferralLink {
  id        String              @id @default(cuid())
  code      String              @unique // Código único ou personalizado
  url       String              // URL completa para compartilhamento
  referrerId String?            // ID do usuário associado (opcional)
  status    ReferralLinkStatus  @default(ACTIVE)
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt

  // Relations
  referrer User? @relation("ReferralLinksCreated", fields: [referrerId], references: [id], onDelete: SetNull)

  @@index([referrerId])
  @@index([status])
  @@index([code])
  @@index([createdAt])
  @@map("referral_links")
}

model Employee {
  id                 String              @id @default(cuid())
  businessProfileId  String
  userId             String              // ID do usuário funcionário
  name               String              // Nome do funcionário (cópia para fácil busca)
  email              String              // Email do funcionário (cópia para fácil busca)
  phone              String?             // Telefone do funcionário
  cpf                String?             // CPF do funcionário (para identificação)
  status             EmployeeStatus      @default(ACTIVE)
  permissions        String              // JSON array de EmployeePermission
  notes              String?             @db.Text // Notas sobre o funcionário
  hireDate           DateTime?           // Data de contratação
  salary             Decimal?            @db.Decimal(10, 2) // Salário (opcional)

  createdAt          DateTime            @default(now())
  createdBy          String?             // ID do usuário que criou o registro
  updatedAt          DateTime            @updatedAt
  updatedBy          String?             // ID do usuário que atualizou o registro

  // Relations
  businessProfile    BusinessProfile     @relation(fields: [businessProfileId], references: [id], onDelete: Cascade)
  user               User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([businessProfileId, userId]) // Um usuário pode ser funcionário de uma empresa apenas uma vez
  @@index([businessProfileId])
  @@index([userId])
  @@index([status])
  @@index([email])
  @@map("employees")
}

model WhatsAppQueue {
  id              String                @id @default(cuid())
  userId          String                // ID do usuário destinatário
  phone           String                // Número de telefone em formato E.164 (+5511999999999)
  message         String                @db.Text // Conteúdo da mensagem
  status          WhatsAppQueueStatus   @default(PENDING) // Status do envio

  // Agendamento
  scheduledAt     DateTime?             // Data/hora agendada para envio (null = enviar imediatamente)

  // Histórico de envio
  sentAt          DateTime?             // Quando foi realmente enviado
  failureReason   String?               // Motivo da falha (se houver)
  retryCount      Int                   @default(0) // Número de tentativas
  maxRetries      Int                   @default(3) // Máximo de tentativas

  // Inteligência de intervalo
  lastSentAt      DateTime?             // Último envio para este usuário (para evitar spam)
  minInterval     Int                   @default(300) // Intervalo mínimo em segundos entre envios (padrão: 5 minutos)

  // Metadata
  metadata        Json?                 // Dados adicionais (tipo de mensagem, referência a transação, etc)

  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt

  // Relations
  user            User                  @relation("UserWhatsAppQueue", fields: [userId], references: [id], onDelete: Cascade)
  attempts        WhatsAppAttempt[]     @relation("QueueAttempts")

  @@index([userId])
  @@index([status])
  @@index([scheduledAt])
  @@index([createdAt])
  @@index([phone])
  @@map("whatsapp_queue")
}

model WhatsAppAttempt {
  id              String                @id @default(cuid())
  queueId         String                // ID da mensagem na fila
  status          WhatsAppAttemptStatus @default(PENDING) // Status da tentativa

  // Detalhes da tentativa
  attemptNumber   Int                   // Número desta tentativa (1, 2, 3...)
  sentAt          DateTime?             // Quando foi enviado (null se ainda não enviado)
  responseCode    Int?                  // Código de resposta da API WhatsApp
  responseMessage String?               // Mensagem de resposta
  failureReason   String?               // Motivo da falha (se houver)

  // WhatsApp API Response
  apiResponseId   String?               // ID retornado pela API WhatsApp (HubStackLine)
  apiResponseData Json?                 // Dados completos da resposta da API

  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt

  // Relations
  queue           WhatsAppQueue         @relation("QueueAttempts", fields: [queueId], references: [id], onDelete: Cascade)

  @@index([queueId])
  @@index([status])
  @@index([createdAt])
  @@map("whatsapp_attempt")
}

model PaymentLink {
  id            String   @id @default(cuid())
  sellerComment String?  @db.Text
  proofUrls     Json?
  metadata      Json?

  // Relations
  // Adicione as relações necessárias aqui

  @@map("payment_links")
}

model PasswordResetCode {
  id        String   @id @default(cuid())
  userId    String
  email     String
  code      String   // Código de 6 dígitos
  expiresAt DateTime // Expira em 15 minutos
  used      Boolean  @default(false)
  attempts  Int      @default(0) // Tentativas de verificação

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([email])
  @@index([code])
  @@index([expiresAt])
  @@map("password_reset_codes")
}
