generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  USER
  SELLER
  ADMIN
}

enum AuthProvider {
  LOCAL
  GOOGLE
  FACEBOOK
}

enum PersonType {
  PF
  PJ
}

enum BusinessProfileStatus {
  UNVERIFIED
  VERIFIED
  CANCELLED
}

model User {
  id           String        @id @default(cuid())
  email        String        @unique
  name         String
  password     String?
  avatar       String?
  phone        String?
  cpf          String?       @unique
  birthDate    DateTime?
  whatsapp     String?
  instagram    String?
  facebook     String?
  role         UserRole      @default(USER)
  provider     AuthProvider? @default(LOCAL)
  providerId   String?
  status       String        @default("ACTIVE")
  isVerified   Boolean       @default(false)
  isActive     Boolean       @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  businessProfiles      BusinessProfile[]
  sessions              Session[]
  whatsappInstances     WhatsAppInstance[]
  whatsappMessageLogs   WhatsAppMessageLog[]

  messagingInstances    MessagingInstance[]
  messagingMessages     MessagingMessage[]

  scheduledMessages  ScheduledMessage[]
  scheduledTasks      ScheduledTask[]
  
  categories Category[]
  products   Product[]
  quotes     Quote[]
  stockEntries StockEntry[]
  @@map("users")
}

model BusinessProfile {
  id     String @id @default(cuid())
  userId String

  personType PersonType @default(PJ)
  status     BusinessProfileStatus @default(UNVERIFIED)

  cpf String? @unique
  companyName String?
  cnpj        String? @unique
  tradingName String?
  description String? @db.Text
  companyLogo String?
  categories  String?

  cep          String?
  street       String?
  number       String?
  complement   String?
  neighborhood String?
  city         String?
  state        String?
  latitude     Float?
  longitude    Float?

  instagram String?
  facebook  String?
  whatsapp  String?
  website   String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("business_profiles")
}

model Session {
  id           String   @id @default(cuid())
  userId       String
  accessToken  String   @unique
  refreshToken String   @unique
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model WhatsAppInstance {
  id           String   @id @default(cuid())
  userId       String
  instanceName String   @unique
  phoneNumber  String?
  status       String   @default("close")
  state        String   @default("DISCONNECTED")
  qrCode       String?  @db.LongText
  webhookUrl   String?

  lastConnectedAt DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  user         User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  messageLogs  WhatsAppMessageLog[]

  @@index([userId])
  @@index([instanceName])
  @@map("whatsapp_instances")
}

model WhatsAppMessageLog {
  id           String   @id @default(cuid())
  userId       String
  instanceId   String
  remoteJid    String
  message      String   @db.Text
  messageId    String   @unique
  direction    String   @default("sent")
  status       String   @default("pending")
  mediaUrl     String?
  error        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user     User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  instance WhatsAppInstance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([instanceId])
  @@index([messageId])
  @@map("whatsapp_message_logs")
}

// Nova tabela genérica para instâncias de messageria (WhatsApp, SMS, Email, Telegram, etc)
model MessagingInstance {
  id                  String   @id @default(cuid())
  userId              String
  channel             String   // 'whatsapp', 'sms', 'email', 'telegram', 'facebook'
  channelInstanceId   String   // ID único no canal (nome da instância, ID do bot, etc)
  channelPhoneOrId    String   // Telefone para WhatsApp, ID para Telegram, email, etc
  status              String   @default("pending") // pending, connecting, connected, disconnected, error
  qrCode              String?  @db.LongText
  metadata            Json?    // Dados específicos do canal em JSON
  lastConnectedAt     DateTime?
  lastDisconnectedAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user            User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  messagingMessages MessagingMessage[]

  @@unique([channel, channelInstanceId])
  @@index([userId])
  @@index([channel])
  @@index([status])
  @@map("messaging_instances")
}

// Nova tabela genérica para logs de mensagens (substitui WhatsAppMessageLog eventualmente)
model MessagingMessage {
  id               String   @id @default(cuid())
  userId           String
  instanceId       String
  channel          String   // 'whatsapp', 'sms', 'email', 'telegram', 'facebook'
  remoteJid        String   // Destinatário: número, ID, email, etc
  message          String   @db.Text
  channelMessageId String?  // ID gerado pelo canal
  direction        String   @default("sent") // sent, received
  status           String   @default("pending") // pending, sent, delivered, read, failed
  mediaUrl         String?
  mediaType        String?  // image, audio, document, video
  error            String?
  retries          Int      @default(0)
  maxRetries       Int      @default(3)
  sentAt           DateTime?
  deliveredAt      DateTime?
  readAt           DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user     User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  instance MessagingInstance @relation(fields: [instanceId], references: [id], onDelete: Cascade)

  @@unique([channelMessageId])
  @@index([userId])
  @@index([instanceId])
  @@index([channel])
  @@index([status])
  @@map("messaging_messages")
}

model ScheduledMessage {
  id           String   @id @default(cuid())
  userId       String
  instanceName String
  phoneNumber  String
  message      String   @db.Text
  scheduledFor DateTime
  
  status   String    @default("pending") // pending, sent, failed
  sentAt   DateTime?
  error    String?
  messageId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([scheduledFor])
  @@index([status])
  @@map("scheduled_messages")
}

model ScheduledTask {
  id           String   @id @default(cuid())
  userId       String
  actionType   String   // whatsapp_message, api_call, email, webhook, custom
  payload      Json     // dados específicos da ação
  scheduledFor DateTime
  
  status   String    @default("pending") // pending, processing, completed, failed
  result   Json?     // resultado da execução
  error    String?
  attempts Int       @default(0)
  maxRetries Int     @default(3)

  executedAt DateTime?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([scheduledFor])
  @@index([status])
  @@index([actionType])
  @@map("scheduled_tasks")
}

// Tabelas de inventário/produtos
model Category {
  id          String   @id @default(cuid())
  userId      String
  name        String
  description String?  @db.Text
  icon        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  products Product[]

  @@unique([userId, name])
  @@index([userId])
  @@map("categories")
}

model Product {
  id          String   @id @default(cuid())
  userId      String
  categoryId  String
  name        String
  description String?  @db.Text
  sku         String
  price       Float
  quantity    Int
  image       String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  quoteItems QuoteItem[]
  stockEntries StockEntry[]

  @@unique([userId, sku])
  @@index([userId])
  @@index([categoryId])
  @@map("products")
}

model Quote {
  id          String   @id @default(cuid())
  userId      String
  quoteNumber String?
  status      String   @default("pending") // pending, sent, accepted, rejected
  discount    Float    @default(0)
  tax         Float    @default(0)
  total       Float

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  items      QuoteItem[]

  @@index([userId])
  @@index([status])
  @@map("quotes")
}

model QuoteItem {
  id        String   @id @default(cuid())
  quoteId   String
  productId String
  quantity  Int
  unitPrice Float
  total     Float

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  quote   Quote   @relation(fields: [quoteId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([quoteId])
  @@index([productId])
  @@map("quote_items")
}

model StockEntry {
  id        String   @id @default(cuid())
  userId    String
  productId String
  quantity  Int
  type      String   @default("in") // in, out, adjustment
  reason    String?
  reference String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([productId])
  @@map("stock_entries")
}
